\documentclass[aspectratio=169]{beamer}

\usetheme{metropolis}
\usepackage{amsmath, amsfonts, amssymb, graphicx, bm}
\usepackage{listings}
\usepackage{xcolor}

% code listing style
\lstset{
  basicstyle=\ttfamily\tiny,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!10},
  xleftmargin=0.5cm,
  xrightmargin=0.5cm,
  columns=flexible,
  keepspaces=true
}

\title{Progress Report: Edge Computing Energy--Latency Optimization}
\subtitle{Scheduling with Nonlinear Trade-offs in the Energy Sector}
\author{Sunoh Ryu}
\date{\today}

\begin{document}

\maketitle

%===========================================================%
\section{Project Overview}

\begin{frame}{Revisiting the Problem}
  \textbf{Original Proposal:} Energy-latency co-optimization for task scheduling in edge computing for the energy sector.

  
  \textbf{Key Challenge:} Mixed-integer nonlinear program (MINLP)
  \begin{equation*}
    \min_{x_{ij},\, f_i}
    \sum_{i=1}^{M}
    \left[
      E_i(x,f) + \lambda \sum_{j=1}^{N} x_{ij} L_{ij}(f_i)
    \right]
  \end{equation*}

  
  \textbf{Subject to:}
  \begin{itemize}
    \item Task assignment constraints: $\sum_i x_{ij} = 1, \forall j$
    \item Frequency bounds: $f_i^{\min} \le f_i \le f_i^{\max}, \forall i$
    \item Stability: $\rho_i < 1, \forall i$ where $\rho_i = \frac{\sum_j x_{ij}\lambda_j}{\kappa_i f_i}$
    \item Binary assignments: $x_{ij} \in \{0,1\}$
  \end{itemize}
\end{frame}

\begin{frame}{Solution Approach}
  \textbf{Hybrid Bi-Level Optimization Framework:}

  \begin{itemize}
    \item \textbf{Outer Layer:} Discrete search over task assignment $x_{ij}$
    \begin{itemize}
      \item Tabu Search (to be implemented)
      \item Particle Swarm Optimization (to be implemented)
    \end{itemize}

    \item \textbf{Inner Layer:} Continuous frequency optimization $f_i$
    \begin{itemize}
      \item Gradient-based local search
      \item Penalty function for constraint violations
    \end{itemize}
  \end{itemize}

  
  \textbf{Penalty Function for Stability:}
  \begin{equation*}
    p(\rho_i) = \eta \, [\max(0,\rho_i - 1 + \epsilon)]^2
  \end{equation*}
\end{frame}

%===========================================================%
\section{Implementation Progress}

\begin{frame}{Overall Progress Summary}
  \textbf{Status: 27/84 tasks completed (32\%)}

  
  \begin{itemize}
    \item[\checkmark] \textbf{Phase 1:} Project Setup (8/8 completed)
    \item[\checkmark] \textbf{Phase 2:} Core Mathematical Models (11/11 completed)
    \item[\checkmark] \textbf{Phase 3:} Inner Layer - Frequency Optimization (3/3 completed)
    \item[\checkmark] \textbf{Phase 4:} Outer Layer - Tabu Search (2/2 completed)
    \item[\checkmark] \textbf{Phase 5:} Outer Layer - PSO (2/2 completed)
    \item[$\square$] \textbf{Phase 6:} Dataset Acquisition (0/9 pending)
    \item[$\square$] \textbf{Phase 7:} Baseline Algorithms (0/7 pending)
    \item[$\square$] \textbf{Phase 8:} Evaluation Framework (0/9 pending)
    \item[$\square$] \textbf{Phase 9:} Visualization (0/7 pending)
    \item[$\square$] \textbf{Phase 10:} Testing \& Validation (0/5 pending)
    \item[$\square$] \textbf{Phase 11:} Documentation (0/3 pending)
  \end{itemize}
\end{frame}

\begin{frame}{Completed Modules}
  \textbf{Mathematical Models:}
  \begin{itemize}
    \item \texttt{src/models/task.py} - Task representation
    \item \texttt{src/models/server.py} - Edge server model
    \item \texttt{src/models/network.py} - Network delay model
    \item \texttt{src/models/power.py} - Dynamic and total power models
    \item \texttt{src/models/utilization.py} - Server utilization calculation
    \item \texttt{src/models/energy.py} - Energy consumption model
    \item \texttt{src/models/queueing.py} - M/M/1 queueing delay
    \item \texttt{src/models/latency.py} - Total latency calculation
    \item \texttt{src/models/objective.py} - Objective function $J(x,f)$
    \item \texttt{src/models/feasibility.py} - Feasibility checker
  \end{itemize}

\end{frame}

\begin{frame}{Completed Modules}
  \textbf{Optimization Algorithms:}
  \begin{itemize}
    \item \texttt{src/algorithms/penalty.py} - Penalty function
    \item \texttt{src/algorithms/gradient.py} - Gradient calculations
    \item \texttt{src/algorithms/freq\_optimizer.py} - Frequency optimizer (inner layer)
    \item \texttt{src/algorithms/neighbors.py} - Neighborhood generation
    \item \texttt{src/algorithms/tabu\_search.py} - Tabu Search (outer layer)
    \item \texttt{src/algorithms/pso.py} - Particle Swarm Optimization (outer layer)
  \end{itemize}
\end{frame}

%===========================================================%
\section{Module Verification}

\begin{frame}[fragile]{Phase 1: Infrastructure}
  \textbf{src/config.py} - System parameter configuration
  \begin{itemize}
    \item Manages global settings: task count, server count, frequency bounds
    \item Validates parameter ranges (e.g., $\gamma \in [2,3]$)
    \item Provides update methods for dynamic configuration
  \end{itemize}

  \begin{lstlisting}
default config: tasks=10, servers=3, gamma=2.5
updated problem size: tasks=20, servers=5
\end{lstlisting}

  
  \textbf{src/utils.py} - Helper utilities
  \begin{itemize}
    \item Random seed control for reproducibility
    \item Timer decorator for performance profiling
    \item Validation functions for parameter bounds and matrix shapes
  \end{itemize}

  \begin{lstlisting}
random seed test passed: [0.37454012 0.95071431 0.73199394]
test_func took 0.1001s
all validation tests passed\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Phase 2: Task and Server Models}
  \textbf{src/models/task.py} - Task representation with arrival rate $\lambda_j$, CPU cycles $c_j$, and data size $d_j$
  \begin{lstlisting}
created task: Task(id=0, lambda=2.50, cycles=1e+08, data=50000.0)
generated 5 random tasks with varying parameters
\end{lstlisting}

  
  \textbf{src/models/server.py} - Edge server with frequency $f_i$ and capacity $\kappa_i$
  \begin{itemize}
    \item Dynamic frequency adjustment: $f_i \in [f_i^{\min}, f_i^{\max}]$
    \item Capacity calculation: $\mu_i = \kappa_i f_i$
    \item Validates frequency bounds to prevent invalid configurations
  \end{itemize}

  \begin{lstlisting}
created server: EdgeServer(id=0, freq=1.00e+09, cap=1.50e+09)
freq set to 2.00e+09
capacity: 3.00e+09 (correctly computed)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Phase 2: Network and Power Models}
  \textbf{src/models/network.py} - Network delay: $L_{ij}^{\text{net}} = \tau_{ij} + \beta_{ij} d_j$
  \begin{itemize}
    \item Propagation delay $\tau_{ij}$ and transmission rate $\beta_{ij}$
    \item Generates random network parameters for N tasks and M servers
  \end{itemize}

  \begin{lstlisting}
network delay: 0.0055s (computed correctly)
generated tau and beta matrices of shape (5, 3)
\end{lstlisting}

  
  \textbf{src/models/power.py} - Power consumption model
  \begin{itemize}
    \item Dynamic power: $P_{\text{dyn}}(f_i) = \alpha_i f_i^{\gamma}$
    \item Total power: $P_i(f_i, \rho_i) = P_{i,0} + \rho_i \alpha_i f_i^{\gamma}$
    \item Validated across different $\gamma$ values (2.0, 2.5, 3.0)
  \end{itemize}

  \begin{lstlisting}
dynamic power at gamma=2.5: 8.94e+13W (verified)
total power with utilization: 6.26e+13W (verified)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Phase 2: Utilization and Energy Models}
  \textbf{src/models/utilization.py} - Server utilization: $\rho_i = \frac{\sum_j x_{ij}\lambda_j}{\kappa_i f_i}$
  \begin{itemize}
    \item Computes per-server utilization from task assignments
    \item Critical for stability constraint: $\rho_i < 1$
  \end{itemize}

  \begin{lstlisting}
utilization computed correctly for single and multiple tasks
calc_all_utilizations: [1.e-09 2.e-09] (verified)
\end{lstlisting}

  
  \textbf{src/models/energy.py} - Energy: $E_i = P_i(f_i, \rho_i) \cdot T$
  \begin{itemize}
    \item Energy per server and total system energy
    \item Aggregates across all servers for objective function
  \end{itemize}

  \begin{lstlisting}
energy: 360000.00J (matches expected)
total energy: 2.68e+17J (sum verified)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Phase 2: Queueing and Latency Models}
  \textbf{src/models/queueing.py} - M/M/1 queueing delay: $W_{q,i} = \frac{\rho_i}{\mu_i(1-\rho_i)}$
  \begin{itemize}
    \item Service time: $S_{ij} = \frac{c_j}{\kappa_i f_i}$
    \item Returns $\infty$ for unstable systems ($\rho_i \ge 1$)
    \item Captures nonlinear relationship between utilization and delay
  \end{itemize}

  \begin{lstlisting}
queueing delay: 2.33e-09s (verified)
high utilization (0.99): 9.90e-08s (sharp increase)
unstable system: inf (correctly detected)
\end{lstlisting}

  
  \textbf{src/models/latency.py} - Total latency: $L_{ij} = L_{ij}^{\text{net}} + W_{q,i} + S_{ij}$
  \begin{lstlisting}
total latency: 0.055250s (network + queueing + service)
latency decreases with frequency:
  1GHz: 0.105s, 1.5GHz: 0.072s, 2GHz: 0.055s
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Phase 2: Objective and Feasibility}
  \textbf{src/models/objective.py} - Objective: $J(x,f) = \sum_i [E_i + \lambda \sum_j x_{ij} L_{ij}]$
  \begin{itemize}
    \item Combines energy consumption and weighted latency
    \item Tunable trade-off parameter $\lambda$ controls emphasis
    \item Evaluates total cost for given assignment and frequencies
  \end{itemize}

  \begin{lstlisting}
objective: 4.24e+08 (energy: 4.24e+08J, latency: 1.88s)
tested with different lambda weights
unbalanced assignment increases objective to 4.71e+08
\end{lstlisting}

  
  \textbf{src/models/feasibility.py} - Solution validator
  \begin{itemize}
    \item Checks each task assigned to exactly one server
    \item Validates frequency bounds: $f_i \in [f_i^{\min}, f_i^{\max}]$
    \item Verifies stability: $\rho_i < 1$ (with soft check near boundary)
  \end{itemize}

  \begin{lstlisting}
feasible assignment: True
detected unassigned task and multiple assignments
detected frequency out of bounds
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Phase 3: Inner Layer Optimization}
  \textbf{src/algorithms/penalty.py} - Penalty: $p(\rho_i) = \eta [\max(0, \rho_i - 1 + \epsilon)]^2$
  \begin{itemize}
    \item Soft constraint enforcement for stability ($\rho_i < 1$)
    \item Quadratic penalty grows sharply as utilization approaches 1
    \item Tunable parameters $\eta$ (strength) and $\epsilon$ (buffer)
  \end{itemize}

  \begin{lstlisting}
utilization 0.7: penalty=0 (safe)
utilization 0.96: penalty=0.10 (warning)
utilization 1.1: penalty=22.50 (violation)
\end{lstlisting}

  
  \textbf{src/algorithms/gradient.py} - Gradient computation
  \begin{itemize}
    \item Energy gradient: $\frac{\partial E_i}{\partial f_i} = T \gamma \rho_i \alpha_i f_i^{\gamma-1}$
    \item Latency gradient: numerical approximation via finite differences
    \item Captures trade-off: $+$ for energy, $-$ for latency
  \end{itemize}

  \begin{lstlisting}
energy gradient at f=2GHz: 2.41e+08 (positive)
latency gradient: -2.77e-10 (negative, reduces latency)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Phase 3: Gradient Calculation}
  \textbf{Test: src/algorithms/gradient.py}
  \begin{lstlisting}
energy gradient at f=2.00e+09, util=0.6: 2.41e+08
calc_energy_gradient test passed
energy gradient at different frequencies:
  f=1.00e+09Hz: grad=8.54e+07
  f=1.50e+09Hz: grad=1.57e+08
  f=2.00e+09Hz: grad=2.41e+08
  f=2.50e+09Hz: grad=3.38e+08
energy gradient at different utilizations:
  util=0.3: grad=1.21e+08
  util=0.5: grad=2.01e+08
  util=0.7: grad=2.82e+08
  util=0.9: grad=3.62e+08

latency gradient (numerical): -2.769066e-10
calc_latency_gradient_numerical test passed
latency gradient sign: negative (reduces latency)

\end{lstlisting}

  \textbf{Key Insight:} Gradients correctly capture the trade-off: increasing frequency raises energy (positive gradient) but reduces latency (negative gradient).
\end{frame}

\begin{frame}[fragile]{Phase 3: Frequency Optimizer}
  \textbf{src/algorithms/freq\_optimizer.py} - Inner layer continuous optimization
  \begin{itemize}
    \item For fixed assignment $x$, optimizes frequencies $f_i$ via gradient descent
    \item Caches server arrival rates: $\lambda_i = \sum_j x_{ij}\lambda_j$
    \item Enforces frequency bounds and penalizes constraint violations
  \end{itemize}

  \begin{lstlisting}
initial objective: 4.24e+08
optimal frequencies: [1.e+09 1.e+09]
optimal objective: 4.24e+08
optimization success: True
tested with different lambda weights
\end{lstlisting}

  
  \textbf{Key Achievement:} Inner layer optimization ready for integration with outer metaheuristics.
\end{frame}

\begin{frame}[fragile]{Phase 4: Tabu Search}
  \textbf{src/algorithms/neighbors.py} - Neighborhood generation
  \begin{itemize}
    \item Swap: exchange tasks between two servers
    \item Move: relocate single task to different server
    \item Returns modified assignment matrix and move descriptor
  \end{itemize}

  \begin{lstlisting}
swap neighbor: exchange task 3 and 4 between servers
move neighbor: relocate task 2 from server 0 to server 1
both operations maintain feasibility constraints
\end{lstlisting}
  
  \textbf{src/algorithms/tabu\_search.py} - Outer layer discrete search
  \begin{itemize}
    \item Tabu list prevents cycling to recently visited solutions
    \item Aspiration criterion allows tabu moves if they improve best solution
    \item Integrates inner frequency optimizer for each candidate
    \item Tracks convergence history for analysis
  \end{itemize}

  \begin{lstlisting}
initial objective: 4.24e+08
iteration 0: new best: 3.94e+08
iteration 2: final best: 3.77e+08
improvement: 11.00%, best solution feasible
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Phase 5: Particle Swarm Optimization}
  \textbf{src/algorithms/pso.py} - Alternative outer layer metaheuristic
  \begin{itemize}
    \item Particle position: continuous vector discretized to assignment matrix
    \item Velocity update: $v_{id} = \omega v_{id} + c_1 r_1 (p_{id} - x_{id}) + c_2 r_2 (g_d - x_{id})$
    \item Position update: $x_{id} = x_{id} + v_{id}$
    \item Tracks personal best (pbest) and global best (gbest)
  \end{itemize}

  \begin{lstlisting}
initialized swarm of 5 particles
initial gbest: 7.05e+08
PSO optimization converged
best solution feasible: True
\end{lstlisting}

  
  \textbf{Achievement:} Two complete bi-level optimization frameworks implemented:
  \begin{itemize}
    \item Tabu Search + Gradient-based frequency optimization
    \item PSO + Gradient-based frequency optimization
  \end{itemize}
\end{frame}

%===========================================================%
\section{Next Steps}

\begin{frame}{Phase 6-7: Datasets and Baselines}
  \textbf{Dataset Acquisition \& Processing}
  \begin{itemize}
    \item Download Google Cluster Workload Trace 2019
    \item Obtain/generate EdgeBench synthetic workloads
    \item Implement data loaders and preprocessors
    \item Compute dataset statistics
  \end{itemize}

  
  \textbf{Baseline Algorithms}
  \begin{itemize}
    \item \textbf{Greedy Minimum Latency:} Assign by lowest network delay
    \item \textbf{Energy-Aware Greedy:} Assign by lowest energy increase
    \item \textbf{Round Robin:} Simple load balancing
    \item Each with inner-layer frequency optimization for fair comparison
  \end{itemize}

  
  \textbf{Purpose:} Validate that proposed hybrid optimization outperforms simple heuristics.
\end{frame}

\begin{frame}{Phase 8: Evaluation}
  \textbf{Evaluation Framework}
  \begin{itemize}
    \item Metrics: total energy, mean/median/95th percentile latency
    \item Pareto frontier generation across $\lambda$ values
    \item Convergence tracking for metaheuristics
    \item Statistical validation and comparison with baselines
  \end{itemize}

\end{frame}
\begin{frame}{Phase 9:Visualization}
  
  \textbf{Visualization}
  \begin{itemize}
    \item Energy vs. latency Pareto plots
    \item Convergence curves (objective value vs. iteration)
    \item Server utilization distribution charts
    \item Frequency allocation heatmaps
    \item Latency distribution histograms
    \item Summary statistics tables
  \end{itemize}

  
  \textbf{Deliverable:} Comprehensive experimental results demonstrating solver effectiveness.
\end{frame}

\begin{frame}{Phase 10-11: Testing and Documentation}
  \textbf{Testing \& Validation}
  \begin{itemize}
    \item Comprehensive unit tests for all modules
    \item Integration tests across model and algorithm layers
    \item End-to-end testing with small problem instances (N=5, M=2)
    \item Validation against known optimal solutions for simplified cases
    \item Full experiments with real datasets
  \end{itemize}

  
  \textbf{Documentation \& Cleanup}
  \begin{itemize}
    \item Code documentation following project standards
    \item README with architecture diagram and usage examples
    \item Compliance review with \texttt{instructions.md}
    \item Final report and presentation preparation
  \end{itemize}
\end{frame}

\end{document}
